
TODO

Currently a Journey uses an InstanceID as identifier, it only needs (and should be changed to) using a CitizenID, or even just a ushort citizenID reference number



__________________________ historic ________________________________________

            // NOTE: an InstanceID has just one member - although calls like InstanceID.Citizen and InstanceID.Vehicle
            // might suggest it could contain two or more things.  It cannot.  It has *either* a citizen or a vehice (or a ...) never both
            // If the instance is a vehicle then InstanceID.Vehicle returns the vehicle number (ie index of vehicle in vehicleManager)
            // if it is not a vehicle then InstanceID.Vehicle returns 0



            
            // I HAVE HAD A BRAINWAVE. INSTEAD OF REWRITING ALL THE RENDERING STUFF TO ACCOUNT FOR CHANGING MODE OF TRANSPORT ALONG A PATH
            // JUST SPLIT PATHS INTO CHUNKS THAT DO ACTUALLY HAVE THE SAME MODE OF TRANSPORT THROUGHOUT
            // IT WILL INVOLVE A SUBSTANTIAL CHANGE TO THE PATH MANAGEMENT IN PARTICULAR STEPPATHS, BUT I THINK IT WILL BE MASSIVELY EASIER THAN MESSING WITH THE RENDERING STUFF
            // PROBLEM: AT THE MOMENT M_PATHS IS NOT A LINKED LIST, IT ONLY CONTAINS ONE PATHUNIT PER ENTITY (WHEN IT HITS THE END, IT GETS THE NEXT PATH FROM PATHMANAGER)
            // also I am getting worried that functions like TransportLine.FillPathSegments use *actual* paths from the PathManager and not PV/JV paths
            // - and rightly worried, they definitely do.  Going to have to think about it some more ...

            // BRAINWAVE2 - maybe I am doing much more than I need. Could it be that if I just switch all the laneTypes and vehicleTypes on for every path then they will all get shown?
            // it has GOT to be worth trying this first!! (I maybe won't be able to change colour when change transport, but I can maybe live with that.)

            /* CONCLUSION so far.  Brainwave2 works for a first attempt, it does show journeys.  But, horribly.  It shows public transport as straight lines between
             * public transport nodes, not the path of the vehicles.  This might actually be considered ok, except that I cannot find a way to make the paths overwrite
             * buildings - ie buildings interrupt the paths.  In the limit you can't even see the paths.  They are also affected by terrain (not showing on steep/too far underground).
             * SO: this is not going to be enough.  And taking it to the next stage is a LOT to do - in plan
             * 
             * 1) replace paths by journeys which ALSO contain the whole broken-down path information segment by segement (contrast PV which just points to the path in pathmanager)
             * 2) while re-segmenting from path to journey, convert from transportline nodes (eg tramstops) to ordinary nodes (where the tramstop is) AND - this is the difficult bit -
             *      recalculate the path for the vehicle going A' to B' instead of along the hidden transportline segment A to B.
             *      I *THINK* I can pick up the mesh for a transport line, they are stored in transportmanager with line number as reference.  So what I will need to get these is
             *      to work out the/a suitable line number, and then find the right part of the mesh (I think mesh knows absolute location, ie in vector3 type, not nodes)
             *      If I can pick the right part of the mesh somehow, I will not necessarily need to map A' to A and B' to B. Just mapping A' to position could be enough.
             *      In other words I would leave the transport segment as it is in the journey steps, but have a really different way of rendering it compared to a pedestrian step.
             * 2B) to be able to render those journeys, need to change refs in all the rendering stuff (including routines from transportline.cs) to journeys instead of paths
             *      (this needs changing no matter how smart I get picking up transportline meshes.  My keeping history could mean ref to a path that no longer exists in pathmanager.)
             * 
             * Major extra benefit: from Brainwave1, journeys can be rendered in parts that have the same mode of transport, so I will be able to custom colour by
             * segment instead of being forced to one colour and one material for the entire path
             * 
             * Side benefit: creating my own Journeys will enable me to keep entire journeys that PV would have deleted, as PV only ever starts from current position
             * But note: while I want to keep as much history as possible, showing all journeys through (ie to and from) a big selection like a segment or metro station
             * is actually very hard to read.  I need a toggle to allow user to restrict to TO, FROM or BOTH TO AND FROM.
             */


CITIZENINSTANCE (in some code, assigned to object named citizenData)

Useful things to know about a CitizenInstance (from looking at ResidentAI.GetLocalizedStatus)

m_sourceBuilding is the beginning and
m_targetBuilding is the end of a *journey* (GUI effectively says "going to <m_targetBuilding>")
 - is always set (else GUI describes them as "confused", game will eventually remove them)
	- "set" includes set to indicate travelling "outside" (always a building not a node in this case)
 - it can be either a netNode or a Building ID number
	- this is equally true for public transport or cars, walking or cycling - only home, work and outside are *always* building not node
 - this is flagged in CitizenInstance.Flags.TargetIsNode (but I do not yet understand why sometimes node and sometimes building ref ID)

m_targetPos is a vector4 that can be set as a position "close" to the target node of a transportline vehicle (close based on lane, laneoffset, segment)

m_targetSeed is a random byte (0 to 255) assigned in SetPath (currently I do not know what it is for)

m_homeBuilding is "lives at" (as a building ID number, never a netNode ID)
m_workBuilding is "works at" (as a building ID number, never a netNode ID) [work is school for a student, otherwise identical functionality]



Some CitizenInstance flags I now know about:

CitizenInstance.Flags.Character		is set on Spawn, indicates that the CI exists on the GUI (and then unset on Unspawn)
									NOTE - Unspawn does not remove them from the game, it just removes them from the Grid
CitizenInstance.Flags.HangAround	indicates "staying where they are" (not moving anywhere). Can be at home, at work, or visiting
									NOTE - for GUI to report this as "at home" etc, ALSO requires m_path==0
									(I am pretty sure they will be indicated as "confused" if HangAround with nonzero m_path)
CitizenInstance.Flags.OnTour		Travelling to a location that is not home, work or outside (eg visiting a park)


CITIZEN

m_vehicle - Pretty sure it is zero when on a public transport vehicle
		(well, I know it is *sometimes* nonzero then, but I think this = on a bike in public transport)

		It is primarily set by citizenAI.SetVehicle (and this is called by nearly all the person-AI)
		SetVehicle always clears the current m_vehicle to 0 (if it wasn't zero already)
		If called with a nonzero UnitID, it adds citizen to units and sets m_vehicle to the relevant unit.m_vehicle (unless AddToUnit fails)
		With a 0 unitID and a 0 vehicle ID, returns with m_vehicle 0
		With a 0 unitID and a nonzero vehicleID, the citizen is added to units and m_vehicle is set to the vehicleID per the call (unless AddtoUnit fails)

	-->	ETC ETC - for now, I think it is clear that m_vehicle ordinarily shows the vehicle the citizen is on at the moment
		BUT when on public transport, the m_vehicle is set for the UNIT and for the citizens individually it is 0

CurrentLocation	- the important thing to know about this is that it is not location! It is one of Home, Work, Visit or Moving


Some Citizen flags (in m_flags) I know about:

Citizen.Flags.Student				if they are a student.  In this case "work" is switched with "school" (only a name difference)
Citizen.Flags.Original				A child born in the city gets this flag
Citizen.Flags.NeedGoods				Needs to go shopping (set in sim step for home unit in ResidentAI called from CitizenManager sim step impl)
Citizen.Flags.DummyTraffic			No idea what this one means, at the moment



CITIZENUNIT

Discovered from CitizenUnit.SimulationStep et seq that a Unit can be CitizenUnit.Flags.Home as well as on a vehicle - ie not just for public transport (I thought wrong)



CITIZENAI/HUMANAI/RESIDENTAI/TOURISTAI

the function SetCurrentVehicle (a BIG wrapper to SetVehicle, does much else) is going to be worth exploring, this includes when citizens are
getting on to public transport


=============================================================================================================================================================

SIMULATION MANAGERS
At the (nearly) highest level, SimulationManager runs all the Manager's SimulationStep sequentially
This is where arg subStep is set - it runs from 0 to 0 if finalSimulationSpeed is zero (or 1 to finalSimulationSpeed if finalSimulationSpeed is not zero)
(it marks the number of times SimulationStep is called before breaking out of the loop and doing a TerrainModify step)
--> subStep=0 means the game is paused, the Manager-simsteps test for this and quick exit doing nothing if subStep is 0

This interfaces through ISimulationManager to SimulationManagerBase, which does this:
  public void SimulationStep(int subStep)
  {
    this.m_simulationProfiler.BeginStep();		<--- this sets up a stopwatch
    try
    {
      this.SimulationStepImpl(subStep);			<--- we see here that it is SimulationStepImpl rather than SimulationStep that is called for Managers
    }
    finally
    {
      this.m_simulationProfiler.EndStep();		<- this records stopwatch times and processes them (not really followed this aspect)
    }
  }

In fact the Managers DO also have a SimulationStep, implemented as ISimulationManager.SimulationsStep
in all the Managers I looked at, this is then redirected to SimulationManagerBase.SimulationStep (which then calls SimulationStepImpl as just above)

For the "children" of a Manager, the simulation step is generally conveniently called SimulationStep, but it would not need to be. Unless an object inherits
from the SimulationManager and is known there, a method called SimulationStep would not *automatically* be run - it is the Managers that call these methods

CitizenManager calls three separate CitizenAI.SimulationStep (they are functionally distinguished by different arg types)
- The second call, ie the sim step with args (homeID, CitizenUnit) is about updating the family at home,  making babies, check for moving away, check if need to go shopping
	this step only has nontrivial implementation for ResidentAI




_________________________ unused code _______________________


        // map a Vehicle.Type into a TransportInfo object - this is going to have to change, JV does not have vehicle IDs in the path
        // am going to have to write a new function that returns the info based on a citizen ID and the pathposition-segment determining which vehicle type they will be on
        // at the moment this is not called at all, everything is set to metro

        private TransportInfo GetTransportInfo(Journey path)
        {
            if (path.m_id.Vehicle != 0)
            {
                VehicleInfo info = Singleton<VehicleManager>.instance.m_vehicles.m_buffer[path.m_id.Vehicle].Info;
                if (info != null)
                {
                    VehicleInfo.VehicleType vehicleType = info.m_vehicleType;
                    switch (vehicleType)
                    {
                        case VehicleInfo.VehicleType.Metro:
                            return Singleton<TransportManager>.instance.GetTransportInfo(TransportInfo.TransportType.Metro);
                        case VehicleInfo.VehicleType.Train:
                            return Singleton<TransportManager>.instance.GetTransportInfo(TransportInfo.TransportType.Train);
                        default:
                            if (vehicleType != VehicleInfo.VehicleType.Ship)
                            {
                                if (vehicleType != VehicleInfo.VehicleType.Plane)
                                {
                                    if (vehicleType == VehicleInfo.VehicleType.Tram)
                                        return Singleton<TransportManager>.instance.GetTransportInfo(TransportInfo.TransportType.Tram);
                                    if (vehicleType != VehicleInfo.VehicleType.Helicopter)
                                    {
                                        if (vehicleType != VehicleInfo.VehicleType.Ferry)
                                        {
                                            if (vehicleType == VehicleInfo.VehicleType.Monorail)
                                                return Singleton<TransportManager>.instance.GetTransportInfo(TransportInfo.TransportType.Monorail);
                                            if (vehicleType == VehicleInfo.VehicleType.CableCar)
                                                return Singleton<TransportManager>.instance.GetTransportInfo(TransportInfo.TransportType.CableCar);
                                            if (vehicleType != VehicleInfo.VehicleType.Blimp)
                                                return Singleton<TransportManager>.instance.GetTransportInfo(TransportInfo.TransportType.Bus);
                                        }
                                        else
                                            goto label_13;
                                    }
                                }
                                return Singleton<TransportManager>.instance.GetTransportInfo(TransportInfo.TransportType.Airplane);
                            }
                        label_13:
                            return Singleton<TransportManager>.instance.GetTransportInfo(TransportInfo.TransportType.Ship);
                    }
                }
            }
            else if (path.m_id.CitizenInstance != 0)
                return Singleton<TransportManager>.instance.GetTransportInfo(TransportInfo.TransportType.Bus);
            return null;
        }

